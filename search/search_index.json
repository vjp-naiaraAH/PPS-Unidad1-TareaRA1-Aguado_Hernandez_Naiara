{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unidad 1 - Tarea RA1: Prueba de Aplicaciones Aplicaci\u00f3n: Lavadero de coches Alumna : Naiara Aguado Hern\u00e1ndez Fecha : 19 de diciembre de 2025 Objetivos de la tarea Esta actividad tiene los siguientes objetivos: Analizar y comprender la estructura interna del c\u00f3digo (clases, m\u00e9todos, flujos de control) y su modelo de ejecuci\u00f3n (transiciones de estado y manejo de excepciones) para determinar los puntos cr\u00edticos de prueba. Aplicar las herramientas del IDE (Integrated Development Environment) para la ejecuci\u00f3n, depuraci\u00f3n paso a paso y seguimiento del flujo de control, identificando y resolviendo posibles errores l\u00f3gicos o de sintaxis. Dise\u00f1ar, implementar y ejecutar pruebas unitarias que cubran la totalidad de los requisitos funcionales y no funcionales, validando la l\u00f3gica individual de cada componente del c\u00f3digo. Verificar que la aplicaci\u00f3n maneja correctamente las reglas de negocio (precios, transiciones de fase y gesti\u00f3n de estados de error), tal como se define en la documentaci\u00f3n. Ejecutar la aplicaci\u00f3n en un entorno controlado para simular su comportamiento en un contexto real, validando la interacci\u00f3n entre sus componentes y el entorno de runtime. \u00cdndice de contenidos 1. Elementos de Python (Documentaci\u00f3n del c\u00f3digo) 2. Ejecuci\u00f3n y Depuraci\u00f3n 3. Pruebas unitarias 4. Ejecuci\u00f3n en Sandbox 5. Reflexi\u00f3n sobre seguridad de lenguajes 1. Elementos de Python (Documentaci\u00f3n del c\u00f3digo) He documentado detalladamente el c\u00f3digo fuente lavadero.py mediante un Jupyter Notebook donde explico l\u00ednea por l\u00ednea la estructura, constantes, m\u00e9todos y flujo de control del programa. Resumen de elementos clave documentados Elemento Descripci\u00f3n breve class Lavadero Clase principal que simula el t\u00fanel de lavado Constantes FASE_* Representan las 9 fases del proceso (0-8) __init__ Inicializa el lavadero cumpliendo requisito 1 @property Acceso de solo lectura a atributos privados terminar() Restablece el estado inicial hacerLavado(...) Inicia lavado con validaci\u00f3n de reglas (requisitos 2 y 3) _cobrar() C\u00e1lculo de ingresos seg\u00fan opciones (requisitos 4-8) avanzarFase() Gesti\u00f3n del flujo de fases (requisitos 9-14) imprimir_estado() Visualizaci\u00f3n completa del estado actual 2. Ejecuci\u00f3n y Depuraci\u00f3n He ejecutado la aplicaci\u00f3n en el IDE VS Code, tanto en terminal como con depuraci\u00f3n visual, identificando y corrigiendo errores de sintaxis y l\u00f3gicos. Resumen de actividades realizadas Actividad Descripci\u00f3n breve Ejecuci\u00f3n en terminal Uso del comando PYTHONPATH=src python3 src/main_app.py Correcci\u00f3n de errores TypeError por par\u00e1metro faltante y otros errores iniciales Depuraci\u00f3n visual Breakpoints, panel de variables, avance paso a paso (F10) Detecci\u00f3n de errores l\u00f3gicos Transiciones incorrectas en fases (detectado en fase 5) 3. Pruebas unitarias He dise\u00f1ado e implementado 14 pruebas unitarias con unittest que cubren todos los requisitos funcionales (precios, excepciones, flujo de fases). Resumen de pruebas realizadas Tipo de prueba Descripci\u00f3n breve Test 1 Estado inicial del lavadero Tests 2-3 Excepciones ValueError (requisitos 2 y 3) Tests 4-8 C\u00e1lculo correcto de ingresos seg\u00fan opciones Tests 9-14 Secuencia exacta de fases para cada combinaci\u00f3n de opciones Ejecuci\u00f3n final Todos los tests pasan con -v 4. Ejecuci\u00f3n en Sandbox He ejecutado la aplicaci\u00f3n en un entorno aislado usando Firejail en Kali Linux, demostrando el aislamiento completo del programa. Resumen de actividades realizadas Actividad Descripci\u00f3n breve Instalaci\u00f3n sudo apt install firejail firetools Ejecuci\u00f3n firejail --private=. python3 main_app.py Aislamiento Sin acceso a red, archivos reales ni otros procesos Resultado Programa ejecutado correctamente dentro del sandbox 5. Reflexi\u00f3n sobre seguridad de lenguajes Reflexi\u00f3n personal comparando medidas de seguridad en lenguajes como Python, Java, Rust y C/C++, basada en contenidos te\u00f3ricos y b\u00fasquedas. Temas tratados Tema Descripci\u00f3n breve Manejo de memoria Python (GC) vs Rust (ownership) vs C (manual) Excepciones y errores Try/except en Python vs checked exceptions en Java Vulnerabilidades comunes Inyecciones, overflows, race conditions Lenguajes m\u00e1s seguros Rust como referente actual Herramientas utilizadas IDE : Visual Studio Code Documentaci\u00f3n del c\u00f3digo : Jupyter Notebook (.ipynb) Depuraci\u00f3n : Run and Debug integrado Pruebas : unittest Sandbox : Firejail en Kali Linux Documentaci\u00f3n final : MkDocs con tema Material Repositorio : GitHub + GitHub Pages Aguado Hern\u00e1ndez Naiara","title":"Home"},{"location":"#unidad-1-tarea-ra1-prueba-de-aplicaciones","text":"Aplicaci\u00f3n: Lavadero de coches Alumna : Naiara Aguado Hern\u00e1ndez Fecha : 19 de diciembre de 2025","title":"Unidad 1 - Tarea RA1: Prueba de Aplicaciones"},{"location":"#objetivos-de-la-tarea","text":"Esta actividad tiene los siguientes objetivos: Analizar y comprender la estructura interna del c\u00f3digo (clases, m\u00e9todos, flujos de control) y su modelo de ejecuci\u00f3n (transiciones de estado y manejo de excepciones) para determinar los puntos cr\u00edticos de prueba. Aplicar las herramientas del IDE (Integrated Development Environment) para la ejecuci\u00f3n, depuraci\u00f3n paso a paso y seguimiento del flujo de control, identificando y resolviendo posibles errores l\u00f3gicos o de sintaxis. Dise\u00f1ar, implementar y ejecutar pruebas unitarias que cubran la totalidad de los requisitos funcionales y no funcionales, validando la l\u00f3gica individual de cada componente del c\u00f3digo. Verificar que la aplicaci\u00f3n maneja correctamente las reglas de negocio (precios, transiciones de fase y gesti\u00f3n de estados de error), tal como se define en la documentaci\u00f3n. Ejecutar la aplicaci\u00f3n en un entorno controlado para simular su comportamiento en un contexto real, validando la interacci\u00f3n entre sus componentes y el entorno de runtime.","title":"Objetivos de la tarea"},{"location":"#indice-de-contenidos","text":"1. Elementos de Python (Documentaci\u00f3n del c\u00f3digo) 2. Ejecuci\u00f3n y Depuraci\u00f3n 3. Pruebas unitarias 4. Ejecuci\u00f3n en Sandbox 5. Reflexi\u00f3n sobre seguridad de lenguajes","title":"\u00cdndice de contenidos"},{"location":"#1-elementos-de-python-documentacion-del-codigo","text":"He documentado detalladamente el c\u00f3digo fuente lavadero.py mediante un Jupyter Notebook donde explico l\u00ednea por l\u00ednea la estructura, constantes, m\u00e9todos y flujo de control del programa.","title":"1. Elementos de Python (Documentaci\u00f3n del c\u00f3digo)"},{"location":"#resumen-de-elementos-clave-documentados","text":"Elemento Descripci\u00f3n breve class Lavadero Clase principal que simula el t\u00fanel de lavado Constantes FASE_* Representan las 9 fases del proceso (0-8) __init__ Inicializa el lavadero cumpliendo requisito 1 @property Acceso de solo lectura a atributos privados terminar() Restablece el estado inicial hacerLavado(...) Inicia lavado con validaci\u00f3n de reglas (requisitos 2 y 3) _cobrar() C\u00e1lculo de ingresos seg\u00fan opciones (requisitos 4-8) avanzarFase() Gesti\u00f3n del flujo de fases (requisitos 9-14) imprimir_estado() Visualizaci\u00f3n completa del estado actual","title":"Resumen de elementos clave documentados"},{"location":"#2-ejecucion-y-depuracion","text":"He ejecutado la aplicaci\u00f3n en el IDE VS Code, tanto en terminal como con depuraci\u00f3n visual, identificando y corrigiendo errores de sintaxis y l\u00f3gicos.","title":"2. Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"#resumen-de-actividades-realizadas","text":"Actividad Descripci\u00f3n breve Ejecuci\u00f3n en terminal Uso del comando PYTHONPATH=src python3 src/main_app.py Correcci\u00f3n de errores TypeError por par\u00e1metro faltante y otros errores iniciales Depuraci\u00f3n visual Breakpoints, panel de variables, avance paso a paso (F10) Detecci\u00f3n de errores l\u00f3gicos Transiciones incorrectas en fases (detectado en fase 5)","title":"Resumen de actividades realizadas"},{"location":"#3-pruebas-unitarias","text":"He dise\u00f1ado e implementado 14 pruebas unitarias con unittest que cubren todos los requisitos funcionales (precios, excepciones, flujo de fases).","title":"3. Pruebas unitarias"},{"location":"#resumen-de-pruebas-realizadas","text":"Tipo de prueba Descripci\u00f3n breve Test 1 Estado inicial del lavadero Tests 2-3 Excepciones ValueError (requisitos 2 y 3) Tests 4-8 C\u00e1lculo correcto de ingresos seg\u00fan opciones Tests 9-14 Secuencia exacta de fases para cada combinaci\u00f3n de opciones Ejecuci\u00f3n final Todos los tests pasan con -v","title":"Resumen de pruebas realizadas"},{"location":"#4-ejecucion-en-sandbox","text":"He ejecutado la aplicaci\u00f3n en un entorno aislado usando Firejail en Kali Linux, demostrando el aislamiento completo del programa.","title":"4. Ejecuci\u00f3n en Sandbox"},{"location":"#resumen-de-actividades-realizadas_1","text":"Actividad Descripci\u00f3n breve Instalaci\u00f3n sudo apt install firejail firetools Ejecuci\u00f3n firejail --private=. python3 main_app.py Aislamiento Sin acceso a red, archivos reales ni otros procesos Resultado Programa ejecutado correctamente dentro del sandbox","title":"Resumen de actividades realizadas"},{"location":"#5-reflexion-sobre-seguridad-de-lenguajes","text":"Reflexi\u00f3n personal comparando medidas de seguridad en lenguajes como Python, Java, Rust y C/C++, basada en contenidos te\u00f3ricos y b\u00fasquedas.","title":"5. Reflexi\u00f3n sobre seguridad de lenguajes"},{"location":"#temas-tratados","text":"Tema Descripci\u00f3n breve Manejo de memoria Python (GC) vs Rust (ownership) vs C (manual) Excepciones y errores Try/except en Python vs checked exceptions en Java Vulnerabilidades comunes Inyecciones, overflows, race conditions Lenguajes m\u00e1s seguros Rust como referente actual","title":"Temas tratados"},{"location":"#herramientas-utilizadas","text":"IDE : Visual Studio Code Documentaci\u00f3n del c\u00f3digo : Jupyter Notebook (.ipynb) Depuraci\u00f3n : Run and Debug integrado Pruebas : unittest Sandbox : Firejail en Kali Linux Documentaci\u00f3n final : MkDocs con tema Material Repositorio : GitHub + GitHub Pages Aguado Hern\u00e1ndez Naiara","title":"Herramientas utilizadas"},{"location":"ejecucion_depuracion/","text":"Ejecuci\u00f3n del programa mediante las opciones de Ejecuci\u00f3n y Depuraci\u00f3n de IDE Ejecuci\u00f3n en terminal Configuraci\u00f3n del Entorno Comenc\u00e9 cerciorarme de saber si estaba Python instalado. para ello us\u00e9 el comando python3 --version Seguidamente continu\u00e9 con la creaci\u00f3n del entorno virtual con Python Python -m venv .venv Lo activ\u00e9 con la ejecuci\u00f3n de # Al activarlo ahora en la terminal saldr\u00e1 delante (.venv) como se ve en la siguiente captura de pantalla source .venv/bin/act\u00edvate Tambi\u00e9n instal\u00e9 las dependencias de la siguiente manera pip install -r requirements.txt && pip install -e . Primera ejecuci\u00f3n del c\u00f3digo Para ejecutar el programa se hace poniendo lo siguiente PYTHONPATH=src python src/main_app.py Esta primera ejecuci\u00f3n no se completar\u00e1 puesto que el c\u00f3digo cuenta con m\u00faltiples errores como se puede ver a continuaci\u00f3n l\u00edneas rojas y moradas Por lo tanto como la finalidad es que funcione correctamente es lo que voy ha hacer a continuaci\u00f3n. Errores hallados y posibles soluciones Error 1: Falta de par\u00e1metro en llamada a funci\u00f3n File \"home/PPSnaiara/Desktop/PPS-UNidad1-Tarea1-Aguado_Hernandez_Naiara/src/main_app.py\", line 83 <module> ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) TypeError: ejecutarSimulacion() missing 1 required positional argument 'encerado' Causa La llamada al ejemplo 4 en 'main_app.py' no ten\u00eda el par\u00e1metro obligatorio 'encerado' . Soluci\u00f3n A\u00f1ad\u00ed 'encerado=False' en la llamada del Ejemplo 4. Ahora si vuelvo a ejecutar el c\u00f3digo lo har\u00e1 correctamente. PYTHONPATH=src python src/main_app.py Para finalizar la ejecuci\u00f3n en terminal voy a salir y borrar el entorno virtual con el uso del siguiente comando deactivate && rm -rf .venv Depuraci\u00f3n visual en el IDE (Visual Studio Code) Utilic\u00e9 el depurador de Visual Studio Code para analizar el flujo del programa paso a paso ** Uso de breakpoints** Los breakpoints permiten detener la ejecuci\u00f3n en l\u00edneas espec\u00edficas para inspeccionar el estado del programa. - La llamada al Ejemplo 1 en main_app.py (para observar el inicio de la simulaci\u00f3n completa). - La l\u00ednea lavadero.hacerLavado(...) (para ver c\u00f3mo se configuran las opciones de lavado). - La l\u00ednea lavadero.avanzarFase() dentro del bucle (para controlar el cambio de fases l\u00ednea por l\u00ednea). Ejecuci\u00f3n del c\u00f3digo con Run and Debug Hacer clic sobre el icono de play+insecto Luego clic sobre el bot\u00f3n de Run and Debug Ahora se abrir\u00e1 otro men\u00fa hacia abajo, en el que selecciono la opci\u00f3n Python File En esta captura se aprecian los breakpoints (bolitas rojas), la l\u00ednea parada (amarilla) y los valores iniciales de las variables del lavadero. Al depurar el Ejemplo 1, observ\u00e9 que con secado_a_mano = True y encerado = True , la transici\u00f3n desde fase 5 (rodillos) iba directamente a fase 6 (secado autom\u00e1tico), omitiendo las fases 7 y 8. En esta captura el depurador est\u00e1 parado en avanzarFase() con fase = 5 y opciones de secado/encerado activadas. Al avanzar, pasa err\u00f3neamente a fase 6. Causa : L\u00f3gica de transiciones invertida e incompleta en el m\u00e9todo avanzarFase de lavadero.py . Soluci\u00f3n : Corregido en el Apartado 3 en las pruebas unitarias. Conclusi\u00f3n La ejecuci\u00f3n en terminal permiti\u00f3 detectar y corregir errores de sintaxis, mientras que la depuraci\u00f3n visual con breakpoints y panel de variables revel\u00f3 errores l\u00f3gicos en el flujo de fases. Estas herramientas del IDE fueron esenciales para garantizar un comportamiento correcto antes de pasar a las pruebas unitarias.","title":"Ejecuci\u00f3n del programa mediante las opciones de Ejecuci\u00f3n y Depuraci\u00f3n de IDE"},{"location":"ejecucion_depuracion/#ejecucion-del-programa-mediante-las-opciones-de-ejecucion-y-depuracion-de-ide","text":"","title":"Ejecuci\u00f3n del programa mediante las opciones de Ejecuci\u00f3n y Depuraci\u00f3n de IDE"},{"location":"ejecucion_depuracion/#ejecucion-en-terminal","text":"","title":"Ejecuci\u00f3n en terminal"},{"location":"ejecucion_depuracion/#configuracion-del-entorno","text":"Comenc\u00e9 cerciorarme de saber si estaba Python instalado. para ello us\u00e9 el comando python3 --version Seguidamente continu\u00e9 con la creaci\u00f3n del entorno virtual con Python Python -m venv .venv Lo activ\u00e9 con la ejecuci\u00f3n de # Al activarlo ahora en la terminal saldr\u00e1 delante (.venv) como se ve en la siguiente captura de pantalla source .venv/bin/act\u00edvate Tambi\u00e9n instal\u00e9 las dependencias de la siguiente manera pip install -r requirements.txt && pip install -e .","title":"Configuraci\u00f3n del Entorno"},{"location":"ejecucion_depuracion/#primera-ejecucion-del-codigo","text":"Para ejecutar el programa se hace poniendo lo siguiente PYTHONPATH=src python src/main_app.py Esta primera ejecuci\u00f3n no se completar\u00e1 puesto que el c\u00f3digo cuenta con m\u00faltiples errores como se puede ver a continuaci\u00f3n l\u00edneas rojas y moradas Por lo tanto como la finalidad es que funcione correctamente es lo que voy ha hacer a continuaci\u00f3n.","title":"Primera ejecuci\u00f3n del c\u00f3digo"},{"location":"ejecucion_depuracion/#errores-hallados-y-posibles-soluciones","text":"","title":"Errores hallados y posibles soluciones"},{"location":"ejecucion_depuracion/#error-1-falta-de-parametro-en-llamada-a-funcion","text":"File \"home/PPSnaiara/Desktop/PPS-UNidad1-Tarea1-Aguado_Hernandez_Naiara/src/main_app.py\", line 83 <module> ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) TypeError: ejecutarSimulacion() missing 1 required positional argument 'encerado' Causa La llamada al ejemplo 4 en 'main_app.py' no ten\u00eda el par\u00e1metro obligatorio 'encerado' . Soluci\u00f3n A\u00f1ad\u00ed 'encerado=False' en la llamada del Ejemplo 4. Ahora si vuelvo a ejecutar el c\u00f3digo lo har\u00e1 correctamente. PYTHONPATH=src python src/main_app.py Para finalizar la ejecuci\u00f3n en terminal voy a salir y borrar el entorno virtual con el uso del siguiente comando deactivate && rm -rf .venv","title":"Error 1: Falta de par\u00e1metro en llamada a funci\u00f3n"},{"location":"ejecucion_depuracion/#depuracion-visual-en-el-ide-visual-studio-code","text":"Utilic\u00e9 el depurador de Visual Studio Code para analizar el flujo del programa paso a paso ** Uso de breakpoints** Los breakpoints permiten detener la ejecuci\u00f3n en l\u00edneas espec\u00edficas para inspeccionar el estado del programa. - La llamada al Ejemplo 1 en main_app.py (para observar el inicio de la simulaci\u00f3n completa). - La l\u00ednea lavadero.hacerLavado(...) (para ver c\u00f3mo se configuran las opciones de lavado). - La l\u00ednea lavadero.avanzarFase() dentro del bucle (para controlar el cambio de fases l\u00ednea por l\u00ednea).","title":"Depuraci\u00f3n visual en el IDE (Visual Studio Code)"},{"location":"ejecucion_depuracion/#ejecucion-del-codigo-con-run-and-debug","text":"Hacer clic sobre el icono de play+insecto Luego clic sobre el bot\u00f3n de Run and Debug Ahora se abrir\u00e1 otro men\u00fa hacia abajo, en el que selecciono la opci\u00f3n Python File En esta captura se aprecian los breakpoints (bolitas rojas), la l\u00ednea parada (amarilla) y los valores iniciales de las variables del lavadero. Al depurar el Ejemplo 1, observ\u00e9 que con secado_a_mano = True y encerado = True , la transici\u00f3n desde fase 5 (rodillos) iba directamente a fase 6 (secado autom\u00e1tico), omitiendo las fases 7 y 8. En esta captura el depurador est\u00e1 parado en avanzarFase() con fase = 5 y opciones de secado/encerado activadas. Al avanzar, pasa err\u00f3neamente a fase 6. Causa : L\u00f3gica de transiciones invertida e incompleta en el m\u00e9todo avanzarFase de lavadero.py . Soluci\u00f3n : Corregido en el Apartado 3 en las pruebas unitarias.","title":"Ejecuci\u00f3n del c\u00f3digo con Run and Debug"},{"location":"ejecucion_depuracion/#conclusion","text":"La ejecuci\u00f3n en terminal permiti\u00f3 detectar y corregir errores de sintaxis, mientras que la depuraci\u00f3n visual con breakpoints y panel de variables revel\u00f3 errores l\u00f3gicos en el flujo de fases. Estas herramientas del IDE fueron esenciales para garantizar un comportamiento correcto antes de pasar a las pruebas unitarias.","title":"Conclusi\u00f3n"},{"location":"pruebas/","text":"Realizaci\u00f3n de los test unitarios de la app Lo primero que he hecho ha sido crear una carpeta llamada test, y dentro de la misma he creado un archivo llamado test_lavadero_unittest.py Dentro de este archivo he a\u00f1adido las 14 pruebas Testlavadero utilizando Unittest , con 14 m\u00e9todos de test correspondientes a cada requisito de la tarea. Pruebas realizadas Test 1-3: Estado inicial y excepciones (ValueError) Test 4-8: C\u00e1lculo correcto de ingresos seg\u00fan opciones Test 9-14: Secuencia exacta de fases para cada combinaci\u00f3n de opciones (usando una funci\u00f3n auxiliar ejecutar_y_obtener_fases ) Ejecuci\u00f3n de los test unitarios En este paso como bien dice el t\u00edtulo del mismo voy a ejecutar los test. Lo har\u00e9 con el uso del siguiente comando: Python -m unittest ./tests/test_lavadero_unittest.py -v el cual me ha dado el siguiente resultado: Correcci\u00f3n de fallos ERROR en test 3: Lanza RuntimeError en vez de ValueError cuando el lavadero est\u00e1 ocupado FAIL en test 5 & 7: precios de secado incorrectos (6.20 y 7.70 en vez de 6.00 y 7.50). FAIL en test 9 a 14: flujo de fases mal (siempre va a la fase 6 o 7 cuando no debe y nunca llega a la fase 8) Error 1: excepci\u00f3n lavadero ocupado Causa Falla porque lanzaba RuntimeError en vez de ValueError Soluci\u00f3n Cambi\u00e9 RuntimeError por ValueError Error 2: precios Causa Los precios del encerado y del secado a mano daban err\u00f3neos puesto que estaban invertidos a c\u00f3mo est\u00e1n definidos en las premisas Soluci\u00f3n Poner los precios que ponen en las premisas. Error 3: flujo de fases Causa Si hay secado o encerado va a fase 6 (secado autom\u00e1tico) en vez de 7. Adem\u00e1s nunca llega a fase 8. Soluci\u00f3n Poner tal cual lo que hay en la imagen a continuaci\u00f3n Ejecuci\u00f3n despu\u00e9s de correcci\u00f3n Despu\u00e9s de corregir los fallos mencionados anteriormente volv\u00ed a ejecutar los test unitarios usando el comando mencionado anteriormente: Python -m unittest ./tests/test_lavadero_unittest.py -v Y ahora ya todos los test dan ok. Conclusi\u00f3n Las 14 pruebas unitarias implementadas con unittest cubrieron todos los requisitos, detectando y permitiendo corregir errores en precios, flujo de fases y excepciones. El resultado final con todos los tests pasando confirma la correcci\u00f3n y robustez de la aplicaci\u00f3n.","title":"Realizaci\u00f3n de los test unitarios de la app"},{"location":"pruebas/#realizacion-de-los-test-unitarios-de-la-app","text":"Lo primero que he hecho ha sido crear una carpeta llamada test, y dentro de la misma he creado un archivo llamado test_lavadero_unittest.py Dentro de este archivo he a\u00f1adido las 14 pruebas Testlavadero utilizando Unittest , con 14 m\u00e9todos de test correspondientes a cada requisito de la tarea.","title":"Realizaci\u00f3n de los test unitarios de la app"},{"location":"pruebas/#pruebas-realizadas","text":"Test 1-3: Estado inicial y excepciones (ValueError) Test 4-8: C\u00e1lculo correcto de ingresos seg\u00fan opciones Test 9-14: Secuencia exacta de fases para cada combinaci\u00f3n de opciones (usando una funci\u00f3n auxiliar ejecutar_y_obtener_fases )","title":"Pruebas realizadas"},{"location":"pruebas/#ejecucion-de-los-test-unitarios","text":"En este paso como bien dice el t\u00edtulo del mismo voy a ejecutar los test. Lo har\u00e9 con el uso del siguiente comando: Python -m unittest ./tests/test_lavadero_unittest.py -v el cual me ha dado el siguiente resultado:","title":"Ejecuci\u00f3n de los test unitarios"},{"location":"pruebas/#correccion-de-fallos","text":"ERROR en test 3: Lanza RuntimeError en vez de ValueError cuando el lavadero est\u00e1 ocupado FAIL en test 5 & 7: precios de secado incorrectos (6.20 y 7.70 en vez de 6.00 y 7.50). FAIL en test 9 a 14: flujo de fases mal (siempre va a la fase 6 o 7 cuando no debe y nunca llega a la fase 8)","title":"Correcci\u00f3n de fallos"},{"location":"pruebas/#error-1-excepcion-lavadero-ocupado","text":"Causa Falla porque lanzaba RuntimeError en vez de ValueError Soluci\u00f3n Cambi\u00e9 RuntimeError por ValueError","title":"Error 1: excepci\u00f3n lavadero ocupado"},{"location":"pruebas/#error-2-precios","text":"Causa Los precios del encerado y del secado a mano daban err\u00f3neos puesto que estaban invertidos a c\u00f3mo est\u00e1n definidos en las premisas Soluci\u00f3n Poner los precios que ponen en las premisas.","title":"Error 2: precios"},{"location":"pruebas/#error-3-flujo-de-fases","text":"Causa Si hay secado o encerado va a fase 6 (secado autom\u00e1tico) en vez de 7. Adem\u00e1s nunca llega a fase 8. Soluci\u00f3n Poner tal cual lo que hay en la imagen a continuaci\u00f3n","title":"Error 3: flujo de fases"},{"location":"pruebas/#ejecucion-despues-de-correccion","text":"Despu\u00e9s de corregir los fallos mencionados anteriormente volv\u00ed a ejecutar los test unitarios usando el comando mencionado anteriormente: Python -m unittest ./tests/test_lavadero_unittest.py -v Y ahora ya todos los test dan ok.","title":"Ejecuci\u00f3n despu\u00e9s de correcci\u00f3n"},{"location":"pruebas/#conclusion","text":"Las 14 pruebas unitarias implementadas con unittest cubrieron todos los requisitos, detectando y permitiendo corregir errores en precios, flujo de fases y excepciones. El resultado final con todos los tests pasando confirma la correcci\u00f3n y robustez de la aplicaci\u00f3n.","title":"Conclusi\u00f3n"},{"location":"reflexion/","text":"Reflexi\u00f3n sobre las medidas de seguridad de los principales lenguajes de programaci\u00f3n A continuaci\u00f3n voy ha hacer una opini\u00f3n personal a cerca de las medidas de seguridad que incorporan los diferentes lenguajes de programaci\u00f3n habiendo le\u00eddo el powerpoint proporcionado por el profesor y ampliando la informaci\u00f3n con b\u00fasquedas en internet. \u201cEl lenguaje de programaci\u00f3n que elijas influir\u00e1 tanto en la seguridad de tu software como la cerradura que pones en tu puerta.\u201d \u2014 Bruce Schneier (experto en criptograf\u00eda y ciberseguridad) La cita de Bruce Schneier que abre tanto la teoria de esta unidad como ahora esta reflexi\u00f3n resume perfectamente lo que he aprendido: el lenguaje de programaci\u00f3n que elegimos es la primera y m\u00e1s importante medida de seguridad que aplicamos a nuestro software . Los lenguajes de bajo nivel (C, C++, ensamblador) nos dan control absoluto, pero tambi\u00e9n responsabilidad absoluta. La gesti\u00f3n manual de memoria y los punteros hacen que errores como buffer overflow , use-after-free o desreferenciaci\u00f3n de punteros nulos sean f\u00e1ciles de cometer y extremadamente peligrosos. En 2025 siguen siendo la causa principal de vulnerabilidades cr\u00edticas en sistemas operativos , navegadores y firmware. Los lenguajes de alto nivel incorporan por dise\u00f1o mecanismos que eliminan familias enteras de bugs: La recolecci\u00f3n autom\u00e1tica de basura (presente en Java, C#, Go, Python, PHP 8.x, JavaScript, etc.) evita fugas de memoria y muchos errores de liberaci\u00f3n. La verificaci\u00f3n de l\u00edmites en arrays y la ausencia de aritm\u00e9tica de punteros directos reducen dr\u00e1sticamente los desbordamientos. Los sistemas de tipos est\u00e1ticos fuertes y las comprobaciones en tiempo de compilaci\u00f3n (especialmente avanzadas en lenguajes modernos como Rust) detectan errores de concurrencia y de acceso a memoria antes de la ejecuci\u00f3n. Los entornos de ejecuci\u00f3n controlados (JVM, CLR, sandbox del navegador) a\u00f1aden capas adicionales de aislamiento. Comparativa de medidas de seguridad estructural Lenguaje Gesti\u00f3n de memoria Seguridad de memoria inherente Prevenci\u00f3n de errores comunes (overflow, inyecciones\u2026) Concurrencia segura Protecci\u00f3n estructural C / C++ Manual Muy baja Depende totalmente del programador Manual y propensa \u2605\u2606\u2606\u2606\u2606 Java GC + verificaci\u00f3n bytecode Muy alta Alta (sandbox, prepared statements) Buena \u2605\u2605\u2605\u2605\u2606 C# GC + CLR Muy alta Alta Buena \u2605\u2605\u2605\u2605\u2606 Python GC autom\u00e1tico Alta Buena con frameworks y buenas pr\u00e1cticas Media (GIL) \u2605\u2605\u2605\u2606\u2606 Go GC + canales Muy alta Alta Excelente \u2605\u2605\u2605\u2605\u2606 Rust Ownership / borrow checker M\u00e1xima (garant\u00edas en tiempo de compilaci\u00f3n) Muy alta Excelente \u2605\u2605\u2605\u2605\u2605 PHP 8.x GC autom\u00e1tico Alta Media-alta (seg\u00fan versi\u00f3n y c\u00f3digo) B\u00e1sica \u2605\u2605\u2605\u2606\u2606 JavaScript GC autom\u00e1tico Alta Buena en entornos modernos Excelente (async) \u2605\u2605\u2605\u2606\u2606 Conclusi\u00f3n final En conclusi\u00f3n, aunque ning\u00fan lenguaje garantiza por s\u00ed solo la seguridad absoluta las buenas pr\u00e1cticas, revisiones de c\u00f3digo y actualizaciones siguen siendo imprescindibles , los lenguajes modernos ofrecen niveles de protecci\u00f3n estructural muy superiores a los disponibles hace dos d\u00e9cadas. Por ello, la selecci\u00f3n del lenguaje debe considerarse una decisi\u00f3n estrat\u00e9gica de seguridad desde la fase inicial del proyecto, ya que condiciona directamente qu\u00e9 vulnerabilidades quedar\u00e1n pr\u00e1cticamente eliminadas por dise\u00f1o y cu\u00e1les requerir\u00e1n controles adicionales durante todo el ciclo de vida del software.","title":"Reflexi\u00f3n sobre las medidas de seguridad de los principales lenguajes de programaci\u00f3n"},{"location":"reflexion/#reflexion-sobre-las-medidas-de-seguridad-de-los-principales-lenguajes-de-programacion","text":"A continuaci\u00f3n voy ha hacer una opini\u00f3n personal a cerca de las medidas de seguridad que incorporan los diferentes lenguajes de programaci\u00f3n habiendo le\u00eddo el powerpoint proporcionado por el profesor y ampliando la informaci\u00f3n con b\u00fasquedas en internet. \u201cEl lenguaje de programaci\u00f3n que elijas influir\u00e1 tanto en la seguridad de tu software como la cerradura que pones en tu puerta.\u201d \u2014 Bruce Schneier (experto en criptograf\u00eda y ciberseguridad) La cita de Bruce Schneier que abre tanto la teoria de esta unidad como ahora esta reflexi\u00f3n resume perfectamente lo que he aprendido: el lenguaje de programaci\u00f3n que elegimos es la primera y m\u00e1s importante medida de seguridad que aplicamos a nuestro software . Los lenguajes de bajo nivel (C, C++, ensamblador) nos dan control absoluto, pero tambi\u00e9n responsabilidad absoluta. La gesti\u00f3n manual de memoria y los punteros hacen que errores como buffer overflow , use-after-free o desreferenciaci\u00f3n de punteros nulos sean f\u00e1ciles de cometer y extremadamente peligrosos. En 2025 siguen siendo la causa principal de vulnerabilidades cr\u00edticas en sistemas operativos , navegadores y firmware. Los lenguajes de alto nivel incorporan por dise\u00f1o mecanismos que eliminan familias enteras de bugs: La recolecci\u00f3n autom\u00e1tica de basura (presente en Java, C#, Go, Python, PHP 8.x, JavaScript, etc.) evita fugas de memoria y muchos errores de liberaci\u00f3n. La verificaci\u00f3n de l\u00edmites en arrays y la ausencia de aritm\u00e9tica de punteros directos reducen dr\u00e1sticamente los desbordamientos. Los sistemas de tipos est\u00e1ticos fuertes y las comprobaciones en tiempo de compilaci\u00f3n (especialmente avanzadas en lenguajes modernos como Rust) detectan errores de concurrencia y de acceso a memoria antes de la ejecuci\u00f3n. Los entornos de ejecuci\u00f3n controlados (JVM, CLR, sandbox del navegador) a\u00f1aden capas adicionales de aislamiento.","title":"Reflexi\u00f3n sobre las medidas de seguridad de los principales lenguajes de programaci\u00f3n"},{"location":"reflexion/#comparativa-de-medidas-de-seguridad-estructural","text":"Lenguaje Gesti\u00f3n de memoria Seguridad de memoria inherente Prevenci\u00f3n de errores comunes (overflow, inyecciones\u2026) Concurrencia segura Protecci\u00f3n estructural C / C++ Manual Muy baja Depende totalmente del programador Manual y propensa \u2605\u2606\u2606\u2606\u2606 Java GC + verificaci\u00f3n bytecode Muy alta Alta (sandbox, prepared statements) Buena \u2605\u2605\u2605\u2605\u2606 C# GC + CLR Muy alta Alta Buena \u2605\u2605\u2605\u2605\u2606 Python GC autom\u00e1tico Alta Buena con frameworks y buenas pr\u00e1cticas Media (GIL) \u2605\u2605\u2605\u2606\u2606 Go GC + canales Muy alta Alta Excelente \u2605\u2605\u2605\u2605\u2606 Rust Ownership / borrow checker M\u00e1xima (garant\u00edas en tiempo de compilaci\u00f3n) Muy alta Excelente \u2605\u2605\u2605\u2605\u2605 PHP 8.x GC autom\u00e1tico Alta Media-alta (seg\u00fan versi\u00f3n y c\u00f3digo) B\u00e1sica \u2605\u2605\u2605\u2606\u2606 JavaScript GC autom\u00e1tico Alta Buena en entornos modernos Excelente (async) \u2605\u2605\u2605\u2606\u2606","title":"Comparativa de medidas de seguridad estructural"},{"location":"reflexion/#conclusion-final","text":"En conclusi\u00f3n, aunque ning\u00fan lenguaje garantiza por s\u00ed solo la seguridad absoluta las buenas pr\u00e1cticas, revisiones de c\u00f3digo y actualizaciones siguen siendo imprescindibles , los lenguajes modernos ofrecen niveles de protecci\u00f3n estructural muy superiores a los disponibles hace dos d\u00e9cadas. Por ello, la selecci\u00f3n del lenguaje debe considerarse una decisi\u00f3n estrat\u00e9gica de seguridad desde la fase inicial del proyecto, ya que condiciona directamente qu\u00e9 vulnerabilidades quedar\u00e1n pr\u00e1cticamente eliminadas por dise\u00f1o y cu\u00e1les requerir\u00e1n controles adicionales durante todo el ciclo de vida del software.","title":"Conclusi\u00f3n final"},{"location":"sandboxing/","text":"Sandbox Un sandbox es un entorno controlado , aislado y seguro que se utiliza para ejecutar programas, procesar archivos o probar c\u00f3digo sin que estos tengan la capacidad de afectar al sistema operativo principal ni a otros recursos cr\u00edticos. La idea es crear un \u201cespacio cerrado\u201d, como una caja de arena donde los ni\u00f1os juegan sin peligro, pero aplicado a la inform\u00e1tica. \u00bfPara que sirve? Probar programas o c\u00f3digo sin riesgo de da\u00f1a el sistema Analizar archivos sospechosos (como por ejemplo malware) sin infectar el equipo. Ejecutar aplicaciones con permisos muy limitados Simular entornos para desarrollo o experimentaci\u00f3n \u00bfComo funciona? Un sandbox funciona creando un entorno aislado donde un programa puede ejecutarse sin afectar al sistema real. Para lograrlo, limita los permisos del software: controla qu\u00e9 archivos puede tocar, qu\u00e9 procesos puede ver, cu\u00e1nta memoria puede usar o si puede acceder a internet. Cada acci\u00f3n que intenta realizar pasa por un filtro de seguridad , y el sandbox decide si permitirla o bloquearla. Adem\u00e1s, utiliza un sistema de archivos temporal donde todo lo que el programa hace queda encerrado. De este modo, aunque intente modificar el sistema o comportarse de forma peligrosa, los cambios quedan atrapados en ese espacio aislado y se eliminan al cerrar el sandbox. Esto permite probar c\u00f3digo, analizar archivos o ejecutar software desconocido sin riesgos. Ejemplos de Sandbox M\u00e1quinas virtuales (VirtualBox, VMware) Espacios de pruebas en navegadores (Chrome Sandbox) Herramientas coo Firejail, Sandboxie o Docker Prueba de aplicacion en un entorno controlado (Sandboxing) En esta actividad voy a documentar como he podido realizar la prueba de la aplicaci\u00f3n lavadero en un entorno controlado. Los objetivos de la actividad han sido: - Conocer como se puede ejecutar programas, malware, etc en entornos controlados y aislados para su an\u00e1lisis - Ser capaz de hacer Sandboxing de un programa Instalacion de Firejail y Firetools Ejecuto en el terminal de Kali sudo apt install firejail para instalar el software firejail por si acaso no est\u00e1 instalado en Kali a\u00fan. Ejecuto en la terminal sudo apt install firejail firetools puesto que es necesario ambos paquetes para poder usar correctamente el Sandbox . Ejecucion del Sandbox Ahora s\u00ed ejecuto el programa dentro del Sandbox (entorno seguro) usando el comando firejail --private=. python3 main_app.py Que ser\u00eda el sandbox m\u00e1s b\u00e1sico de firejail El resultado completo del firejail es el siguiente Reading profile /etc/firejail/default.profile Reading profile /etc/firejail/disable-common.inc Reading profile /etc/firejail/disable-programs.inc Reading profile /etc/firejail/landlock-common.inc Warning: networking feature is disabled in Firejail configuration file ** Note: you can use --noprofile to disable default.profile ** firejail version 0.9.76 Parent pid 26642, child pid 26643 Warning: not remounting /var/lib/docker/overlay2/496d8f236f4874b190794e236f2699f12cbfc8a8a534fed6a4b1642cb1115c89/merged Warning: not remounting /var/lib/docker/overlay2/c2b0fd92f4725f7bea99b07c335d646ec916132594f479316b3a19e5bd2a08de/merged Warning: not remounting /var/lib/docker/overlay2/d2b2ff36569c4cc0893906ad61458840c88f3f70ef3c41384022d9558e4c4ee7/merged Warning: not remounting /var/lib/docker/overlay2/7391c3341c935e0a627994b4db7fa67612122c6bb9501220ec77d122f4d01a14/merged Warning: not remounting /var/lib/docker/overlay2/80f06f3463329cda539086cb9cbd8a7b4509bb0dbcdad15d549a62d957ed4e2c/merged Warning: not remounting /var/lib/docker/overlay2/496d8f236f4874b190794e236f2699f12cbfc8a8a534fed6a4b1642cb1115c89/merged Warning: not remounting /var/lib/docker/overlay2/c2b0fd92f4725f7bea99b07c335d646ec916132594f479316b3a19e5bd2a08de/merged Warning: not remounting /var/lib/docker/overlay2/d2b2ff36569c4cc0893906ad61458840c88f3f70ef3c41384022d9558e4c4ee7/merged Warning: not remounting /var/lib/docker/overlay2/7391c3341c935e0a627994b4db7fa67612122c6bb9501220ec77d122f4d01a14/merged Warning: not remounting /var/lib/docker/overlay2/80f06f3463329cda539086cb9cbd8a7b4509bb0dbcdad15d549a62d957ed4e2c/merged Warning: cannot find /var/run/utmp Base filesystem installed in 34.50 ms Child process initialized in 84.63 ms ======================================================= EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: True, Secado a mano: True, Encerado: True] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 0.00 \u20ac Ocupado: True Prelavado a mano: True Secado a mano: True Encerado: True Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 8.70 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 2 - Haciendo prelavado a mano -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 6 - Haciendo secado autom\u00e1tico -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 8.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: False] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: True Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 5.00 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 7 - Haciendo secado a mano -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 13.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 13.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 3: ERROR (Encerado S, Secado a mano N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: True] ERROR DE ARGUMENTO: No se puede encerar el coche sin secado a mano ======================================================= EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N) Traceback (most recent call last): File \"/home/PPSnaiara/main_app.py\", line 83, in <module> ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TypeError: ejecutarSimulacion() missing 1 required positional argument: 'encerado' Parent is shutting down, bye... Como se ve en la pr\u00f3xima im\u00e1gen, el programa se ejecuta dentro de un sandbox completamente aislado del resto del sistema. Esto confirma que la aplicaci\u00f3n queda protegida aunque sea maliciosa o tenga vulnerabilidades. La opci\u00f3n --debug muestra en pantalla todo lo que Firejail est\u00e1 haciendo. Conclusiones y reflexion Gracias al uso de Firejail con la opci\u00f3n --private , la aplicaci\u00f3n Python se ejecut\u00f3 en un entorno completamente aislado: No tiene acceso al sistema de archivos real del host No puede acceder a la red No puede ver ni interactuar con otros procesos Cualquier cambio realizado desaparece al cerrar el sandbox Esto demuestra que incluso si el script hubiera sido malicioso, no podr\u00eda haber afectado al sistema real de Kali Linux. Firejail es una herramienta extremadamente ligera y eficaz para sandboxing r\u00e1pido de aplicaciones en Linux, ideal tanto para an\u00e1lisis de malware como para ejecutar software de procedencia desconocida con seguridad.","title":"Sandbox"},{"location":"sandboxing/#sandbox","text":"Un sandbox es un entorno controlado , aislado y seguro que se utiliza para ejecutar programas, procesar archivos o probar c\u00f3digo sin que estos tengan la capacidad de afectar al sistema operativo principal ni a otros recursos cr\u00edticos. La idea es crear un \u201cespacio cerrado\u201d, como una caja de arena donde los ni\u00f1os juegan sin peligro, pero aplicado a la inform\u00e1tica.","title":"Sandbox"},{"location":"sandboxing/#para-que-sirve","text":"Probar programas o c\u00f3digo sin riesgo de da\u00f1a el sistema Analizar archivos sospechosos (como por ejemplo malware) sin infectar el equipo. Ejecutar aplicaciones con permisos muy limitados Simular entornos para desarrollo o experimentaci\u00f3n","title":"\u00bfPara que sirve?"},{"location":"sandboxing/#como-funciona","text":"Un sandbox funciona creando un entorno aislado donde un programa puede ejecutarse sin afectar al sistema real. Para lograrlo, limita los permisos del software: controla qu\u00e9 archivos puede tocar, qu\u00e9 procesos puede ver, cu\u00e1nta memoria puede usar o si puede acceder a internet. Cada acci\u00f3n que intenta realizar pasa por un filtro de seguridad , y el sandbox decide si permitirla o bloquearla. Adem\u00e1s, utiliza un sistema de archivos temporal donde todo lo que el programa hace queda encerrado. De este modo, aunque intente modificar el sistema o comportarse de forma peligrosa, los cambios quedan atrapados en ese espacio aislado y se eliminan al cerrar el sandbox. Esto permite probar c\u00f3digo, analizar archivos o ejecutar software desconocido sin riesgos.","title":"\u00bfComo funciona?"},{"location":"sandboxing/#ejemplos-de-sandbox","text":"M\u00e1quinas virtuales (VirtualBox, VMware) Espacios de pruebas en navegadores (Chrome Sandbox) Herramientas coo Firejail, Sandboxie o Docker","title":"Ejemplos de Sandbox"},{"location":"sandboxing/#prueba-de-aplicacion-en-un-entorno-controlado-sandboxing","text":"En esta actividad voy a documentar como he podido realizar la prueba de la aplicaci\u00f3n lavadero en un entorno controlado. Los objetivos de la actividad han sido: - Conocer como se puede ejecutar programas, malware, etc en entornos controlados y aislados para su an\u00e1lisis - Ser capaz de hacer Sandboxing de un programa","title":"Prueba de aplicacion en un entorno controlado (Sandboxing)"},{"location":"sandboxing/#instalacion-de-firejail-y-firetools","text":"Ejecuto en el terminal de Kali sudo apt install firejail para instalar el software firejail por si acaso no est\u00e1 instalado en Kali a\u00fan.","title":"Instalacion de Firejail y Firetools"},{"location":"sandboxing/#_1","text":"Ejecuto en la terminal sudo apt install firejail firetools puesto que es necesario ambos paquetes para poder usar correctamente el Sandbox .","title":""},{"location":"sandboxing/#_2","text":"","title":""},{"location":"sandboxing/#ejecucion-del-sandbox","text":"Ahora s\u00ed ejecuto el programa dentro del Sandbox (entorno seguro) usando el comando firejail --private=. python3 main_app.py Que ser\u00eda el sandbox m\u00e1s b\u00e1sico de firejail El resultado completo del firejail es el siguiente Reading profile /etc/firejail/default.profile Reading profile /etc/firejail/disable-common.inc Reading profile /etc/firejail/disable-programs.inc Reading profile /etc/firejail/landlock-common.inc Warning: networking feature is disabled in Firejail configuration file ** Note: you can use --noprofile to disable default.profile ** firejail version 0.9.76 Parent pid 26642, child pid 26643 Warning: not remounting /var/lib/docker/overlay2/496d8f236f4874b190794e236f2699f12cbfc8a8a534fed6a4b1642cb1115c89/merged Warning: not remounting /var/lib/docker/overlay2/c2b0fd92f4725f7bea99b07c335d646ec916132594f479316b3a19e5bd2a08de/merged Warning: not remounting /var/lib/docker/overlay2/d2b2ff36569c4cc0893906ad61458840c88f3f70ef3c41384022d9558e4c4ee7/merged Warning: not remounting /var/lib/docker/overlay2/7391c3341c935e0a627994b4db7fa67612122c6bb9501220ec77d122f4d01a14/merged Warning: not remounting /var/lib/docker/overlay2/80f06f3463329cda539086cb9cbd8a7b4509bb0dbcdad15d549a62d957ed4e2c/merged Warning: not remounting /var/lib/docker/overlay2/496d8f236f4874b190794e236f2699f12cbfc8a8a534fed6a4b1642cb1115c89/merged Warning: not remounting /var/lib/docker/overlay2/c2b0fd92f4725f7bea99b07c335d646ec916132594f479316b3a19e5bd2a08de/merged Warning: not remounting /var/lib/docker/overlay2/d2b2ff36569c4cc0893906ad61458840c88f3f70ef3c41384022d9558e4c4ee7/merged Warning: not remounting /var/lib/docker/overlay2/7391c3341c935e0a627994b4db7fa67612122c6bb9501220ec77d122f4d01a14/merged Warning: not remounting /var/lib/docker/overlay2/80f06f3463329cda539086cb9cbd8a7b4509bb0dbcdad15d549a62d957ed4e2c/merged Warning: cannot find /var/run/utmp Base filesystem installed in 34.50 ms Child process initialized in 84.63 ms ======================================================= EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: True, Secado a mano: True, Encerado: True] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 0.00 \u20ac Ocupado: True Prelavado a mano: True Secado a mano: True Encerado: True Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 8.70 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 2 - Haciendo prelavado a mano -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 6 - Haciendo secado autom\u00e1tico -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 8.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: False] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: True Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 5.00 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 7 - Haciendo secado a mano -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 13.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 13.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 3: ERROR (Encerado S, Secado a mano N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: True] ERROR DE ARGUMENTO: No se puede encerar el coche sin secado a mano ======================================================= EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N) Traceback (most recent call last): File \"/home/PPSnaiara/main_app.py\", line 83, in <module> ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TypeError: ejecutarSimulacion() missing 1 required positional argument: 'encerado' Parent is shutting down, bye...","title":"Ejecucion del Sandbox"},{"location":"sandboxing/#_3","text":"Como se ve en la pr\u00f3xima im\u00e1gen, el programa se ejecuta dentro de un sandbox completamente aislado del resto del sistema. Esto confirma que la aplicaci\u00f3n queda protegida aunque sea maliciosa o tenga vulnerabilidades. La opci\u00f3n --debug muestra en pantalla todo lo que Firejail est\u00e1 haciendo.","title":""},{"location":"sandboxing/#conclusiones-y-reflexion","text":"Gracias al uso de Firejail con la opci\u00f3n --private , la aplicaci\u00f3n Python se ejecut\u00f3 en un entorno completamente aislado: No tiene acceso al sistema de archivos real del host No puede acceder a la red No puede ver ni interactuar con otros procesos Cualquier cambio realizado desaparece al cerrar el sandbox Esto demuestra que incluso si el script hubiera sido malicioso, no podr\u00eda haber afectado al sistema real de Kali Linux. Firejail es una herramienta extremadamente ligera y eficaz para sandboxing r\u00e1pido de aplicaciones en Linux, ideal tanto para an\u00e1lisis de malware como para ejecutar software de procedencia desconocida con seguridad.","title":"Conclusiones y reflexion"}]}